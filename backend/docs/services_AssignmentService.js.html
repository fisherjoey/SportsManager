<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/AssignmentService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/AssignmentService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * AssignmentService - Assignment operations service
 * 
 * This service extends BaseService to provide specialized assignment management
 * operations, including conflict checking, bulk operations, and game status updates.
 * It integrates with the conflict detection service and wage calculation utilities.
 */

const BaseService = require('./BaseService');
const { checkAssignmentConflicts } = require('./conflictDetectionService');
const { calculateFinalWage, getWageBreakdown } = require('../utils/wage-calculator');
const { getOrganizationSettings } = require('../utils/organization-settings');

class AssignmentService extends BaseService {
  constructor(db) {
    super('game_assignments', db, {
      defaultOrderBy: 'created_at',
      defaultOrderDirection: 'desc',
      enableAuditTrail: true
    });
  }

  /**
   * Create a new assignment with comprehensive conflict checking
   * @param {Object} assignmentData - Assignment data
   * @param {Object} options - Creation options
   * @returns {Object} Created assignment with wage breakdown
   */
  async createAssignment(assignmentData, options = {}) {
    return await this.withTransaction(async (trx) => {
      try {
        const { game_id, user_id, position_id, assigned_by } = assignmentData;

        // Validate required fields
        if (!game_id || !user_id || !position_id) {
          throw new Error('game_id, user_id, and position_id are required');
        }

        // Check if game exists
        const game = await trx('games').where('id', game_id).first();
        if (!game) {
          throw new Error('Game not found');
        }

        // Check if referee exists and is available
        const referee = await trx('users')
          .leftJoin('referee_levels', 'users.referee_level_id', 'referee_levels.id')
          .select(
            'users.*',
            'referee_levels.name as level_name',
            'referee_levels.allowed_divisions'
          )
          .where('users.id', user_id)
          .where('users.role', 'referee')
          .first();

        if (!referee) {
          throw new Error('Referee not found or not active');
        }

        // Check if position exists
        const position = await trx('positions').where('id', position_id).first();
        if (!position) {
          throw new Error('Position not found');
        }

        // Check for existing assignments
        const existingPositionAssignment = await trx('game_assignments')
          .where('game_id', game_id)
          .where('position_id', position_id)
          .whereIn('status', ['pending', 'accepted'])
          .first();

        if (existingPositionAssignment) {
          throw new Error('Position already filled for this game');
        }

        const existingRefereeAssignment = await trx('game_assignments')
          .where('game_id', game_id)
          .where('user_id', user_id)
          .whereIn('status', ['pending', 'accepted'])
          .first();

        if (existingRefereeAssignment) {
          throw new Error('Referee already assigned to this game');
        }

        // Check if game has reached maximum referees
        const currentAssignments = await trx('game_assignments')
          .where('game_id', game_id)
          .whereIn('status', ['pending', 'accepted'])
          .count('* as count')
          .first();

        if (parseInt(currentAssignments.count) >= game.refs_needed) {
          throw new Error('Game has reached maximum number of referees');
        }

        // Run comprehensive conflict detection
        const conflictAnalysis = await checkAssignmentConflicts(assignmentData);

        if (conflictAnalysis.hasConflicts) {
          throw new Error(`Assignment conflicts detected: ${conflictAnalysis.errors.join(', ')}`);
        }

        // Get organization settings for wage calculation
        const orgSettings = await getOrganizationSettings();
        const assignedRefereesCount = parseInt(currentAssignments.count) + 1;

        // Calculate final wage
        const finalWage = calculateFinalWage(
          referee.wage_per_game || game.pay_rate,
          game.wage_multiplier || 1.0,
          orgSettings.payment_model || 'INDIVIDUAL',
          orgSettings.default_game_rate || 0,
          assignedRefereesCount
        );

        // Create assignment
        const assignmentRecord = {
          game_id,
          user_id,
          position_id,
          assigned_by,
          status: 'pending',
          assigned_at: new Date(),
          calculated_wage: finalWage
        };

        const assignment = await this.create(assignmentRecord, { transaction: trx });

        // Get wage breakdown for response
        const wageBreakdown = getWageBreakdown(
          referee.wage_per_game || game.pay_rate,
          game.wage_multiplier || 1.0,
          game.wage_multiplier_reason || '',
          orgSettings.payment_model || 'INDIVIDUAL',
          orgSettings.default_game_rate || 0,
          assignedRefereesCount
        );

        // Update game status
        await this._updateGameStatus(game_id, trx);

        return {
          assignment,
          wageBreakdown,
          warnings: conflictAnalysis.warnings || []
        };

      } catch (error) {
        console.error('Error creating assignment:', error);
        throw error;
      }
    });
  }

  /**
   * Bulk update assignment statuses with game status updates
   * @param {Array} updates - Array of update objects
   * @param {Object} options - Update options
   * @returns {Object} Update results
   */
  async bulkUpdateAssignments(updates, options = {}) {
    if (!Array.isArray(updates) || updates.length === 0) {
      throw new Error('Updates array is required and cannot be empty');
    }

    if (updates.length > 100) {
      throw new Error('Maximum 100 assignments can be updated at once');
    }

    return await this.withTransaction(async (trx) => {
      const results = {
        updatedAssignments: [],
        updateErrors: [],
        summary: {
          totalSubmitted: updates.length,
          successfulUpdates: 0,
          failedUpdates: 0
        }
      };

      const affectedGameIds = new Set();

      for (const updateData of updates) {
        try {
          const { assignment_id, status, calculated_wage } = updateData;

          if (!assignment_id || !status) {
            results.updateErrors.push({
              assignmentId: assignment_id,
              error: 'Missing assignment_id or status'
            });
            continue;
          }

          // Validate status
          const validStatuses = ['pending', 'accepted', 'declined', 'completed'];
          if (!validStatuses.includes(status)) {
            results.updateErrors.push({
              assignmentId: assignment_id,
              error: 'Invalid status value'
            });
            continue;
          }

          // Check if assignment exists
          const existingAssignment = await trx('game_assignments')
            .where('id', assignment_id)
            .first();

          if (!existingAssignment) {
            results.updateErrors.push({
              assignmentId: assignment_id,
              error: 'Assignment not found'
            });
            continue;
          }

          // Prepare update data
          const updateFields = {
            status,
            updated_at: new Date()
          };

          if (calculated_wage !== undefined) {
            updateFields.calculated_wage = calculated_wage;
          }

          // Update assignment
          const updatedAssignment = await this.update(
            assignment_id, 
            updateFields, 
            { transaction: trx }
          );

          results.updatedAssignments.push(updatedAssignment);
          results.summary.successfulUpdates++;

          // Track affected games for status updates
          affectedGameIds.add(existingAssignment.game_id);

        } catch (error) {
          console.error(`Error updating assignment ${updateData.assignment_id}:`, error);
          results.updateErrors.push({
            assignmentId: updateData.assignment_id,
            error: error.message
          });
          results.summary.failedUpdates++;
        }
      }

      // Update game statuses for all affected games
      for (const gameId of affectedGameIds) {
        try {
          await this._updateGameStatus(gameId, trx);
        } catch (error) {
          console.error(`Error updating game status for game ${gameId}:`, error);
          // Don't fail the entire transaction for game status update errors
        }
      }

      if (results.summary.successfulUpdates === 0 &amp;&amp; results.summary.failedUpdates > 0) {
        throw new Error('All assignment updates failed');
      }

      return results;
    });
  }

  /**
   * Update game status based on current assignment count
   * @param {string} gameId - Game ID
   * @param {Object} options - Update options
   * @returns {Object} Updated game status
   */
  async updateGameStatus(gameId, options = {}) {
    const trx = options.transaction || this.db;
    return await this._updateGameStatus(gameId, trx);
  }

  /**
   * Get assignments with enhanced data (game, referee, position details)
   * @param {Object} filters - Query filters 
   * @param {number} page - Page number
   * @param {number} limit - Records per page
   * @param {Object} options - Query options
   * @returns {Object} Paginated assignment results
   */
  async getAssignmentsWithDetails(filters = {}, page = 1, limit = 50, options = {}) {
    try {
      const offset = (page - 1) * limit;

      // Build query with all necessary joins
      let query = this.db('game_assignments')
        .join('games', 'game_assignments.game_id', 'games.id')
        .join('users', 'game_assignments.user_id', 'users.id')
        .join('positions', 'game_assignments.position_id', 'positions.id')
        .join('teams as home_team', 'games.home_team_id', 'home_team.id')
        .join('teams as away_team', 'games.away_team_id', 'away_team.id')
        .leftJoin('referee_levels', 'users.referee_level_id', 'referee_levels.id')
        .select(
          'game_assignments.*',
          'games.game_date',
          'games.game_time',
          'games.location',
          'games.level',
          'games.pay_rate',
          'games.wage_multiplier',
          'games.wage_multiplier_reason',
          'home_team.name as home_team_name',
          'away_team.name as away_team_name',
          'users.name as referee_name',
          'users.email as referee_email',
          'positions.name as position_name',
          'referee_levels.name as referee_level'
        );

      // Apply filters
      if (filters.game_id) {
        query = query.where('game_assignments.game_id', filters.game_id);
      }
      if (filters.user_id) {
        query = query.where('game_assignments.user_id', filters.user_id);
      }
      if (filters.status) {
        query = query.where('game_assignments.status', filters.status);
      }
      if (filters.date_from) {
        query = query.where('games.game_date', '>=', filters.date_from);
      }
      if (filters.date_to) {
        query = query.where('games.game_date', '&lt;=', filters.date_to);
      }

      // Get total count
      const countQuery = query.clone().clearSelect().count('* as total').first();
      
      // Apply pagination and ordering
      query = query
        .orderBy('games.game_date', 'asc')
        .limit(limit)
        .offset(offset);

      const [assignments, countResult] = await Promise.all([
        query,
        countQuery
      ]);

      const total = parseInt(countResult.total);
      const totalPages = Math.ceil(total / limit);

      return {
        data: assignments,
        pagination: {
          page: parseInt(page),
          limit: parseInt(limit),
          total,
          totalPages,
          hasNextPage: page &lt; totalPages,
          hasPreviousPage: page > 1
        }
      };

    } catch (error) {
      console.error('Error getting assignments with details:', error);
      throw new Error(`Failed to get assignments: ${error.message}`);
    }
  }

  /**
   * Bulk remove assignments with game status updates
   * @param {Array} assignmentIds - Array of assignment IDs
   * @param {Object} options - Removal options
   * @returns {Object} Removal results
   */
  async bulkRemoveAssignments(assignmentIds, options = {}) {
    if (!Array.isArray(assignmentIds) || assignmentIds.length === 0) {
      throw new Error('Assignment IDs array is required and cannot be empty');
    }

    if (assignmentIds.length > 100) {
      throw new Error('Maximum 100 assignments can be removed at once');
    }

    return await this.withTransaction(async (trx) => {
      try {
        // Get assignments before deletion for game status updates
        const assignmentsToDelete = await trx('game_assignments')
          .whereIn('id', assignmentIds)
          .select('id', 'game_id');

        if (assignmentsToDelete.length === 0) {
          return {
            deletedCount: 0,
            affectedGames: 0,
            warnings: ['No assignments found with provided IDs']
          };
        }

        // Get unique game IDs for status updates
        const gameIds = [...new Set(assignmentsToDelete.map(a => a.game_id))];

        // Delete assignments
        const deletedCount = await trx('game_assignments')
          .whereIn('id', assignmentIds)
          .del();

        // Update game statuses for affected games
        for (const gameId of gameIds) {
          await this._updateGameStatus(gameId, trx);
        }

        const notFoundIds = assignmentIds.filter(id => 
          !assignmentsToDelete.find(a => a.id === id)
        );

        return {
          deletedCount,
          affectedGames: gameIds.length,
          summary: {
            totalRequested: assignmentIds.length,
            successfullyDeleted: deletedCount,
            notFound: notFoundIds.length
          },
          warnings: notFoundIds.length > 0 ? ['Some assignment IDs were not found'] : []
        };

      } catch (error) {
        console.error('Error bulk removing assignments:', error);
        throw error;
      }
    });
  }

  /**
   * Get available referees for a specific game with conflict checking
   * @param {string} gameId - Game ID
   * @param {Object} options - Query options
   * @returns {Array} Available referees with availability analysis
   */
  async getAvailableRefereesForGame(gameId, options = {}) {
    try {
      const game = await this.db('games').where('id', gameId).first();
      if (!game) {
        throw new Error('Game not found');
      }

      // Get potential referees
      const potentialReferees = await this.db('users')
        .leftJoin('referee_levels', 'users.referee_level_id', 'referee_levels.id')
        .select(
          'users.*',
          'referee_levels.name as level_name',
          'referee_levels.allowed_divisions'
        )
        .where('users.role', 'referee')
        .where('users.is_available', true)
        .whereNotExists(function() {
          this.select('*')
            .from('game_assignments')
            .join('games', 'game_assignments.game_id', 'games.id')
            .whereRaw('game_assignments.user_id = users.id')
            .where('games.game_date', game.game_date)
            .where('games.game_time', game.game_time)
            .where('games.id', '!=', gameId)
            .whereIn('game_assignments.status', ['pending', 'accepted']);
        });

      // Analyze each referee for conflicts and qualifications
      const analyzedReferees = [];
      
      for (const referee of potentialReferees) {
        try {
          const assignmentData = {
            game_id: gameId,
            user_id: referee.id,
            position_id: 'dummy' // We're just checking conflicts, not assigning
          };

          const conflictAnalysis = await checkAssignmentConflicts(assignmentData);

          analyzedReferees.push({
            ...referee,
            availability_status: conflictAnalysis.hasConflicts ? 'conflict' : 'available',
            conflicts: conflictAnalysis.conflicts || [],
            warnings: conflictAnalysis.warnings || [],
            is_qualified: conflictAnalysis.isQualified !== false,
            can_assign: !conflictAnalysis.hasConflicts
          });

        } catch (error) {
          console.error(`Error analyzing referee ${referee.id} for game ${gameId}:`, error);
          analyzedReferees.push({
            ...referee,
            availability_status: 'error',
            conflicts: [],
            warnings: [`Analysis error: ${error.message}`],
            is_qualified: false,
            can_assign: false
          });
        }
      }

      return {
        game: {
          id: game.id,
          date: game.game_date,
          time: game.game_time,
          location: game.location,
          level: game.level
        },
        referees: analyzedReferees,
        summary: {
          total: analyzedReferees.length,
          available: analyzedReferees.filter(r => r.can_assign).length,
          conflicts: analyzedReferees.filter(r => r.availability_status === 'conflict').length,
          errors: analyzedReferees.filter(r => r.availability_status === 'error').length
        }
      };

    } catch (error) {
      console.error(`Error getting available referees for game ${gameId}:`, error);
      throw new Error(`Failed to get available referees: ${error.message}`);
    }
  }

  /**
   * Internal method to update game status based on assignments
   * @private
   * @param {string} gameId - Game ID
   * @param {Object} trx - Transaction object
   * @returns {Object} Updated game
   */
  async _updateGameStatus(gameId, trx) {
    try {
      const game = await trx('games').where('id', gameId).first();
      if (!game) {
        throw new Error('Game not found');
      }

      const activeAssignments = await trx('game_assignments')
        .where('game_id', gameId)
        .whereIn('status', ['pending', 'accepted'])
        .count('* as count')
        .first();

      const assignmentCount = parseInt(activeAssignments.count);
      let gameStatus = 'unassigned';

      if (assignmentCount > 0 &amp;&amp; assignmentCount &lt; game.refs_needed) {
        gameStatus = 'assigned'; // Partially assigned
      } else if (assignmentCount >= game.refs_needed) {
        gameStatus = 'assigned'; // Fully assigned
      }

      const [updatedGame] = await trx('games')
        .where('id', gameId)
        .update({ 
          status: gameStatus, 
          updated_at: new Date() 
        })
        .returning('*');

      return updatedGame;

    } catch (error) {
      console.error(`Error updating game status for game ${gameId}:`, error);
      throw error;
    }
  }

  /**
   * Hook called after assignment creation
   * @param {Object} assignment - Created assignment
   * @param {Object} options - Creation options
   */
  async afterCreate(assignment, options) {
    if (this.options.enableAuditTrail) {
      console.log(`Assignment created: ${assignment.id} for game ${assignment.game_id}`);
    }
  }

  /**
   * Hook called after assignment update
   * @param {Object} assignment - Updated assignment
   * @param {Object} previousAssignment - Previous assignment state
   * @param {Object} options - Update options
   */
  async afterUpdate(assignment, previousAssignment, options) {
    if (this.options.enableAuditTrail &amp;&amp; previousAssignment.status !== assignment.status) {
      console.log(`Assignment status changed: ${assignment.id} from ${previousAssignment.status} to ${assignment.status}`);
    }
  }
}

module.exports = AssignmentService;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-routes_assignments.html">routes/assignments</a></li><li><a href="module-routes_games.html">routes/games</a></li></ul><h3>Classes</h3><ul><li><a href="AdvancedPerformanceMetrics.html">AdvancedPerformanceMetrics</a></li><li><a href="ApiError.html">ApiError</a></li><li><a href="AppError.html">AppError</a></li><li><a href="ApprovalWorkflowService.html">ApprovalWorkflowService</a></li><li><a href="AuthenticationError.html">AuthenticationError</a></li><li><a href="AuthorizationError.html">AuthorizationError</a></li><li><a href="global.html#BaseService">BaseService</a></li><li><a href="BudgetCalculationService.html">BudgetCalculationService</a></li><li><a href="BusinessLogicError.html">BusinessLogicError</a></li><li><a href="ConfigurationError.html">ConfigurationError</a></li><li><a href="ConflictError.html">ConflictError</a></li><li><a href="DatabaseError.html">DatabaseError</a></li><li><a href="DistanceCalculationService.html">DistanceCalculationService</a></li><li><a href="EncryptionService.html">EncryptionService</a></li><li><a href="ErrorFactory.html">ErrorFactory</a></li><li><a href="ErrorLogger.html">ErrorLogger</a></li><li><a href="ErrorMetrics.html">ErrorMetrics</a></li><li><a href="ErrorUtils.html">ErrorUtils</a></li><li><a href="ExternalServiceError.html">ExternalServiceError</a></li><li><a href="FileProcessingError.html">FileProcessingError</a></li><li><a href="FinancialAIService.html">FinancialAIService</a></li><li><a href="LocationDataService.html">LocationDataService</a></li><li><a href="MetricsCollector.html">MetricsCollector</a></li><li><a href="NotFoundError.html">NotFoundError</a></li><li><a href="PaymentMethodService.html">PaymentMethodService</a></li><li><a href="QueryBuilder.html">QueryBuilder</a></li><li><a href="QueryCache.html">QueryCache</a></li><li><a href="QueryPerformanceAnalyzer.html">QueryPerformanceAnalyzer</a></li><li><a href="RateLimitError.html">RateLimitError</a></li><li><a href="ResponseFormatter.html">ResponseFormatter</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="ServiceFactory.html">ServiceFactory</a></li><li><a href="TimeoutError.html">TimeoutError</a></li><li><a href="UnprocessableEntityError.html">UnprocessableEntityError</a></li><li><a href="ValidationError.html">ValidationError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AUDIT_EVENTS">AUDIT_EVENTS</a></li><li><a href="global.html#AUDIT_SEVERITY">AUDIT_SEVERITY</a></li><li><a href="global.html#AssignmentSchemas">AssignmentSchemas</a></li><li><a href="global.html#AuthSchemas">AuthSchemas</a></li><li><a href="global.html#AvailabilitySchemas">AvailabilitySchemas</a></li><li><a href="global.html#BaseSchemas">BaseSchemas</a></li><li><a href="global.html#BudgetSchemas">BudgetSchemas</a></li><li><a href="global.html#COMMON_PATTERNS">COMMON_PATTERNS</a></li><li><a href="global.html#CUSTOM_VALIDATORS">CUSTOM_VALIDATORS</a></li><li><a href="global.html#CacheHelpers">CacheHelpers</a></li><li><a href="global.html#CacheInvalidation">CacheInvalidation</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#ERROR_SEVERITY">ERROR_SEVERITY</a></li><li><a href="global.html#ERROR_TYPES">ERROR_TYPES</a></li><li><a href="global.html#FileSchemas">FileSchemas</a></li><li><a href="global.html#FilterSchemas">FilterSchemas</a></li><li><a href="global.html#GameSchemas">GameSchemas</a></li><li><a href="global.html#HTTP_STATUS">HTTP_STATUS</a></li><li><a href="global.html#IdParamSchema">IdParamSchema</a></li><li><a href="global.html#NodeCache">NodeCache</a></li><li><a href="global.html#PaginationSchema">PaginationSchema</a></li><li><a href="global.html#QueryHelpers">QueryHelpers</a></li><li><a href="global.html#SCHEMA_REGISTRY">SCHEMA_REGISTRY</a></li><li><a href="global.html#UserSchemas">UserSchemas</a></li><li><a href="global.html#VALIDATION_OPTIONS">VALIDATION_OPTIONS</a></li><li><a href="global.html#addMinutes">addMinutes</a></li><li><a href="global.html#advancedPerformanceMonitor">advancedPerformanceMonitor</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#auditMiddleware">auditMiddleware</a></li><li><a href="global.html#authLimiter">authLimiter</a></li><li><a href="global.html#autoValidate">autoValidate</a></li><li><a href="global.html#calculateAvailabilityScore">calculateAvailabilityScore</a></li><li><a href="global.html#calculateDatabaseHealthScore">calculateDatabaseHealthScore</a></li><li><a href="global.html#calculateEndTime">calculateEndTime</a></li><li><a href="global.html#calculateFinalWage">calculateFinalWage</a></li><li><a href="global.html#checkAssignmentConflicts">checkAssignmentConflicts</a></li><li><a href="global.html#checkGameSchedulingConflicts">checkGameSchedulingConflicts</a></li><li><a href="global.html#checkRefereeDoubleBooking">checkRefereeDoubleBooking</a></li><li><a href="global.html#checkServiceHealth">checkServiceHealth</a></li><li><a href="global.html#checkTimeOverlap">checkTimeOverlap</a></li><li><a href="global.html#checkTravelTimeConflict">checkTravelTimeConflict</a></li><li><a href="global.html#checkVenueConflict">checkVenueConflict</a></li><li><a href="global.html#clearSettingsCache">clearSettingsCache</a></li><li><a href="global.html#conditionalValidation">conditionalValidation</a></li><li><a href="global.html#createAuditLog">createAuditLog</a></li><li><a href="global.html#createAuditLogsTable">createAuditLogsTable</a></li><li><a href="global.html#createPerformanceRoute">createPerformanceRoute</a></li><li><a href="global.html#createSecurityMiddleware">createSecurityMiddleware</a></li><li><a href="global.html#createTableService">createTableService</a></li><li><a href="global.html#createValidationError">createValidationError</a></li><li><a href="global.html#createValidator">createValidator</a></li><li><a href="global.html#db">db</a></li><li><a href="global.html#determineErrorSeverity">determineErrorSeverity</a></li><li><a href="global.html#determineEventType">determineEventType</a></li><li><a href="global.html#determineHealthStatus">determineHealthStatus</a></li><li><a href="global.html#determineIfShouldLog">determineIfShouldLog</a></li><li><a href="global.html#determineSeverity">determineSeverity</a></li><li><a href="global.html#enforceHTTPS">enforceHTTPS</a></li><li><a href="global.html#enhancedAsyncHandler">enhancedAsyncHandler</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#errorHealthCheck">errorHealthCheck</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#findAvailableReferees">findAvailableReferees</a></li><li><a href="global.html#formatAvailabilityResponse">formatAvailabilityResponse</a></li><li><a href="global.html#formatBytes">formatBytes</a></li><li><a href="global.html#generateAdvancedRecommendations">generateAdvancedRecommendations</a></li><li><a href="global.html#generateCacheRecommendations">generateCacheRecommendations</a></li><li><a href="global.html#generateDatabaseInsights">generateDatabaseInsights</a></li><li><a href="global.html#generateGroupStagePlayoffs">generateGroupStagePlayoffs</a></li><li><a href="global.html#generateHealthRecommendations">generateHealthRecommendations</a></li><li><a href="global.html#generateRecommendations">generateRecommendations</a></li><li><a href="global.html#generateRoundRobin">generateRoundRobin</a></li><li><a href="global.html#generateSingleElimination">generateSingleElimination</a></li><li><a href="global.html#generateSwissSystem">generateSwissSystem</a></li><li><a href="global.html#generateTransactionNumber">generateTransactionNumber</a></li><li><a href="global.html#getAdvancedMetrics">getAdvancedMetrics</a></li><li><a href="global.html#getAggregatedMetrics">getAggregatedMetrics</a></li><li><a href="global.html#getAuditEventType">getAuditEventType</a></li><li><a href="global.html#getClientIP">getClientIP</a></li><li><a href="global.html#getCorsConfig">getCorsConfig</a></li><li><a href="global.html#getErrorMessage">getErrorMessage</a></li><li><a href="global.html#getMetricsCollector">getMetricsCollector</a></li><li><a href="global.html#getMetricsEvents">getMetricsEvents</a></li><li><a href="global.html#getMetricsSummary">getMetricsSummary</a></li><li><a href="global.html#getMinutesBetween">getMinutesBetween</a></li><li><a href="global.html#getOrganizationSettings">getOrganizationSettings</a></li><li><a href="global.html#getPerformanceEvents">getPerformanceEvents</a></li><li><a href="global.html#getPerformanceStats">getPerformanceStats</a></li><li><a href="global.html#getQueryPerformanceEvents">getQueryPerformanceEvents</a></li><li><a href="global.html#getQueryPerformanceStats">getQueryPerformanceStats</a></li><li><a href="global.html#getSecurityConfig">getSecurityConfig</a></li><li><a href="global.html#getService">getService</a></li><li><a href="global.html#getServices">getServices</a></li><li><a href="global.html#getSlowQueriesSummary">getSlowQueriesSummary</a></li><li><a href="global.html#getWageBreakdown">getWageBreakdown</a></li><li><a href="global.html#handleApprovedRequest">handleApprovedRequest</a></li><li><a href="global.html#handleDatabaseError">handleDatabaseError</a></li><li><a href="global.html#hasSchedulingConflict">hasSchedulingConflict</a></li><li><a href="global.html#initializeServices">initializeServices</a></li><li><a href="global.html#knex">knex</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#logRequest">logRequest</a></li><li><a href="global.html#logSuspiciousActivity">logSuspiciousActivity</a></li><li><a href="global.html#logUnauthorizedCorsAttempt">logUnauthorizedCorsAttempt</a></li><li><a href="global.html#metricsEvents">metricsEvents</a></li><li><a href="global.html#notFoundHandler">notFoundHandler</a></li><li><a href="global.html#parseSize">parseSize</a></li><li><a href="global.html#parseSqlQuery">parseSqlQuery</a></li><li><a href="global.html#performanceEvents">performanceEvents</a></li><li><a href="global.html#performanceMonitor">performanceMonitor</a></li><li><a href="global.html#queryAuditLogs">queryAuditLogs</a></li><li><a href="global.html#queryCache">queryCache</a></li><li><a href="global.html#queryPerformanceEvents">queryPerformanceEvents</a></li><li><a href="global.html#queryValidationSchemas">queryValidationSchemas</a></li><li><a href="global.html#requestContextMiddleware">requestContextMiddleware</a></li><li><a href="global.html#requestContexts">requestContexts</a></li><li><a href="global.html#requestSizeLimit">requestSizeLimit</a></li><li><a href="global.html#resetAdvancedMetrics">resetAdvancedMetrics</a></li><li><a href="global.html#resetAllMetrics">resetAllMetrics</a></li><li><a href="global.html#resetPerformanceStats">resetPerformanceStats</a></li><li><a href="global.html#resetQueryPerformanceStats">resetQueryPerformanceStats</a></li><li><a href="global.html#sanitizeAll">sanitizeAll</a></li><li><a href="global.html#sanitizeBody">sanitizeBody</a></li><li><a href="global.html#sanitizeBodyForLogging">sanitizeBodyForLogging</a></li><li><a href="global.html#sanitizeError">sanitizeError</a></li><li><a href="global.html#sanitizeHeaders">sanitizeHeaders</a></li><li><a href="global.html#sanitizeInput">sanitizeInput</a></li><li><a href="global.html#sanitizeObject">sanitizeObject</a></li><li><a href="global.html#sanitizeParams">sanitizeParams</a></li><li><a href="global.html#sanitizeQuery">sanitizeQuery</a></li><li><a href="global.html#sanitizeString">sanitizeString</a></li><li><a href="global.html#securityConfig">securityConfig</a></li><li><a href="global.html#securityMonitoring">securityMonitoring</a></li><li><a href="global.html#sendAlertToWebhook">sendAlertToWebhook</a></li><li><a href="global.html#setupAlertHandlers">setupAlertHandlers</a></li><li><a href="global.html#setupGlobalErrorHandlers">setupGlobalErrorHandlers</a></li><li><a href="global.html#subtractMinutes">subtractMinutes</a></li><li><a href="global.html#testIntegrationConnection">testIntegrationConnection</a></li><li><a href="global.html#trackCacheOperation">trackCacheOperation</a></li><li><a href="global.html#trackDbQuery">trackDbQuery</a></li><li><a href="global.html#updateMetricsConfig">updateMetricsConfig</a></li><li><a href="global.html#validateAvailabilityWindow">validateAvailabilityWindow</a></li><li><a href="global.html#validateBody">validateBody</a></li><li><a href="global.html#validateContentType">validateContentType</a></li><li><a href="global.html#validateEnvironment">validateEnvironment</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateIdParam">validateIdParam</a></li><li><a href="global.html#validateParams">validateParams</a></li><li><a href="global.html#validateQuery">validateQuery</a></li><li><a href="global.html#validateRefereeQualifications">validateRefereeQualifications</a></li><li><a href="global.html#validateRequest">validateRequest</a></li><li><a href="global.html#validateUuidParam">validateUuidParam</a></li><li><a href="global.html#validationSummary">validationSummary</a></li><li><a href="global.html#withDatabaseError">withDatabaseError</a></li><li><a href="global.html#withErrorBoundary">withErrorBoundary</a></li><li><a href="global.html#withServiceTransaction">withServiceTransaction</a></li><li><a href="global.html#wrapDatabaseConnection">wrapDatabaseConnection</a></li><li><a href="global.html#wrapDatabaseQuery">wrapDatabaseQuery</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 01 2025 16:15:52 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
