<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: middleware/advanced-performance.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: middleware/advanced-performance.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Advanced Performance Monitoring Middleware - Package 3C
 * @description Enhanced performance tracking with deep monitoring capabilities,
 * real-time alerting, resource usage tracking, and performance trend analysis.
 * Builds on existing performanceMonitor.js with advanced features.
 */

const { EventEmitter } = require('events');
const { trackDbQuery, trackCacheOperation } = require('./performanceMonitor');
const { ErrorLogger } = require('./enhanced-error-handling');

/**
 * Performance event emitter for real-time alerting
 */
const performanceEvents = new EventEmitter();

/**
 * Advanced performance metrics storage
 */
class AdvancedPerformanceMetrics {
  constructor() {
    this.metrics = {
      // Request metrics
      requests: {
        total: 0,
        active: 0,
        slowCount: 0,
        verySlowCount: 0,
        errorCount: 0,
        totalResponseTime: 0,
        byEndpoint: new Map(),
        byStatusCode: new Map(),
        byUserAgent: new Map(),
        byIpAddress: new Map()
      },
      
      // Resource metrics
      resources: {
        memory: {
          heapUsed: [],
          heapTotal: [],
          external: [],
          rss: [],
          maxHeapUsed: 0,
          maxHeapTotal: 0,
          maxExternal: 0,
          maxRss: 0
        },
        cpu: {
          usage: [],
          maxUsage: 0
        },
        eventLoop: {
          lag: [],
          maxLag: 0
        }
      },
      
      // Database metrics
      database: {
        queries: {
          total: 0,
          slow: 0,
          verySlow: 0,
          errors: 0,
          totalTime: 0,
          byTable: new Map(),
          byOperation: new Map(),
          connectionPool: {
            active: 0,
            idle: 0,
            waiting: 0,
            max: 0
          }
        }
      },
      
      // Cache metrics
      cache: {
        operations: {
          total: 0,
          hits: 0,
          misses: 0,
          invalidations: 0,
          errors: 0
        },
        performance: {
          hitRateHistory: [],
          averageHitRate: 0
        }
      },
      
      // Alert metrics
      alerts: {
        triggered: 0,
        byType: new Map(),
        recent: [],
        maxRecent: 100
      },
      
      // Trend data (circular buffers for performance)
      trends: {
        responseTime: [],
        requestRate: [],
        errorRate: [],
        memoryUsage: [],
        cpuUsage: [],
        maxTrendSize: 288 // 24 hours at 5-minute intervals
      },
      
      // Collection metadata
      metadata: {
        startTime: Date.now(),
        lastReset: Date.now(),
        collectionInterval: 5000, // 5 seconds
        samplingRate: 1.0 // Sample 100% of requests
      }
    };
    
    // Start resource monitoring
    this.startResourceMonitoring();
    this.startTrendCollection();
  }

  /**
   * Record request metrics
   */
  recordRequest(req, res, responseTime, error = null) {
    const endpoint = `${req.method} ${req.route?.path || req.path}`;
    const statusCode = res.statusCode;
    const userAgent = req.get('User-Agent') || 'unknown';
    const ipAddress = req.ip || req.connection.remoteAddress || 'unknown';
    
    // Update counters
    this.metrics.requests.total++;
    this.metrics.requests.totalResponseTime += responseTime;
    
    if (error) {
      this.metrics.requests.errorCount++;
    }
    
    // Categorize response time
    if (responseTime > 5000) { // Very slow: > 5 seconds
      this.metrics.requests.verySlowCount++;
      this.emitAlert('very_slow_request', {
        endpoint,
        responseTime,
        statusCode,
        userAgent,
        ipAddress,
        error: error?.message
      });
    } else if (responseTime > 1000) { // Slow: > 1 second
      this.metrics.requests.slowCount++;
      this.emitAlert('slow_request', {
        endpoint,
        responseTime,
        statusCode,
        userAgent,
        ipAddress
      });
    }
    
    // Update endpoint metrics
    if (!this.metrics.requests.byEndpoint.has(endpoint)) {
      this.metrics.requests.byEndpoint.set(endpoint, {
        count: 0,
        totalTime: 0,
        errorCount: 0,
        slowCount: 0,
        verySlowCount: 0,
        averageTime: 0,
        minTime: Infinity,
        maxTime: 0,
        statusCodes: new Map(),
        recentRequests: []
      });
    }
    
    const endpointMetrics = this.metrics.requests.byEndpoint.get(endpoint);
    endpointMetrics.count++;
    endpointMetrics.totalTime += responseTime;
    endpointMetrics.averageTime = endpointMetrics.totalTime / endpointMetrics.count;
    endpointMetrics.minTime = Math.min(endpointMetrics.minTime, responseTime);
    endpointMetrics.maxTime = Math.max(endpointMetrics.maxTime, responseTime);
    
    if (error) endpointMetrics.errorCount++;
    if (responseTime > 1000) endpointMetrics.slowCount++;
    if (responseTime > 5000) endpointMetrics.verySlowCount++;
    
    // Track status codes for endpoint
    const currentStatusCount = endpointMetrics.statusCodes.get(statusCode) || 0;
    endpointMetrics.statusCodes.set(statusCode, currentStatusCount + 1);
    
    // Keep recent requests (last 10)
    endpointMetrics.recentRequests.push({
      timestamp: Date.now(),
      responseTime,
      statusCode,
      error: error?.message
    });
    if (endpointMetrics.recentRequests.length > 10) {
      endpointMetrics.recentRequests.shift();
    }
    
    // Update global status code tracking
    const globalStatusCount = this.metrics.requests.byStatusCode.get(statusCode) || 0;
    this.metrics.requests.byStatusCode.set(statusCode, globalStatusCount + 1);
    
    // Update user agent tracking
    const userAgentCount = this.metrics.requests.byUserAgent.get(userAgent) || 0;
    this.metrics.requests.byUserAgent.set(userAgent, userAgentCount + 1);
    
    // Update IP address tracking
    const ipCount = this.metrics.requests.byIpAddress.get(ipAddress) || 0;
    this.metrics.requests.byIpAddress.set(ipAddress, ipCount + 1);
  }

  /**
   * Record database query metrics
   */
  recordDbQuery(duration, sql, table = 'unknown', operation = 'unknown', cached = false, error = null) {
    this.metrics.database.queries.total++;
    this.metrics.database.queries.totalTime += duration;
    
    if (error) {
      this.metrics.database.queries.errors++;
    }
    
    if (cached) {
      this.metrics.cache.operations.hits++;
    } else {
      this.metrics.cache.operations.misses++;
    }
    this.metrics.cache.operations.total++;
    
    // Categorize query performance
    if (duration > 2000) { // Very slow: > 2 seconds
      this.metrics.database.queries.verySlow++;
      this.emitAlert('very_slow_query', {
        duration,
        sql: sql?.substring(0, 200),
        table,
        operation,
        cached,
        error: error?.message
      });
    } else if (duration > 500) { // Slow: > 500ms
      this.metrics.database.queries.slow++;
      this.emitAlert('slow_query', {
        duration,
        sql: sql?.substring(0, 200),
        table,
        operation,
        cached
      });
    }
    
    // Update per-table metrics
    if (!this.metrics.database.queries.byTable.has(table)) {
      this.metrics.database.queries.byTable.set(table, {
        count: 0,
        totalTime: 0,
        slowCount: 0,
        verySlowCount: 0,
        errorCount: 0,
        averageTime: 0
      });
    }
    
    const tableMetrics = this.metrics.database.queries.byTable.get(table);
    tableMetrics.count++;
    tableMetrics.totalTime += duration;
    tableMetrics.averageTime = tableMetrics.totalTime / tableMetrics.count;
    if (error) tableMetrics.errorCount++;
    if (duration > 500) tableMetrics.slowCount++;
    if (duration > 2000) tableMetrics.verySlowCount++;
    
    // Update per-operation metrics
    if (!this.metrics.database.queries.byOperation.has(operation)) {
      this.metrics.database.queries.byOperation.set(operation, {
        count: 0,
        totalTime: 0,
        averageTime: 0
      });
    }
    
    const operationMetrics = this.metrics.database.queries.byOperation.get(operation);
    operationMetrics.count++;
    operationMetrics.totalTime += duration;
    operationMetrics.averageTime = operationMetrics.totalTime / operationMetrics.count;
    
    // Also track in existing performanceMonitor for compatibility
    trackDbQuery(duration, sql, cached);
  }

  /**
   * Record cache operation
   */
  recordCacheOperation(operation, hit = null, error = null) {
    this.metrics.cache.operations.total++;
    
    if (error) {
      this.metrics.cache.operations.errors++;
    } else if (operation === 'invalidate') {
      this.metrics.cache.operations.invalidations++;
    } else if (hit === true) {
      this.metrics.cache.operations.hits++;
    } else if (hit === false) {
      this.metrics.cache.operations.misses++;
    }
    
    // Calculate hit rate
    const totalCacheOps = this.metrics.cache.operations.hits + this.metrics.cache.operations.misses;
    if (totalCacheOps > 0) {
      const hitRate = (this.metrics.cache.operations.hits / totalCacheOps) * 100;
      this.metrics.cache.performance.averageHitRate = hitRate;
      
      // Add to history
      this.metrics.cache.performance.hitRateHistory.push({
        timestamp: Date.now(),
        hitRate
      });
      
      // Keep only last 100 entries
      if (this.metrics.cache.performance.hitRateHistory.length > 100) {
        this.metrics.cache.performance.hitRateHistory.shift();
      }
      
      // Alert on low hit rate
      if (hitRate &lt; 30 &amp;&amp; totalCacheOps > 100) {
        this.emitAlert('low_cache_hit_rate', { hitRate, totalOperations: totalCacheOps });
      }
    }
    
    // Also track in existing performanceMonitor for compatibility
    trackCacheOperation(hit);
  }

  /**
   * Start monitoring system resources
   */
  startResourceMonitoring() {
    const monitorResources = () => {
      const memUsage = process.memoryUsage();
      const cpuUsage = process.cpuUsage();
      
      // Update memory metrics
      this.metrics.resources.memory.heapUsed.push({
        timestamp: Date.now(),
        value: memUsage.heapUsed
      });
      this.metrics.resources.memory.heapTotal.push({
        timestamp: Date.now(),
        value: memUsage.heapTotal
      });
      this.metrics.resources.memory.external.push({
        timestamp: Date.now(),
        value: memUsage.external
      });
      this.metrics.resources.memory.rss.push({
        timestamp: Date.now(),
        value: memUsage.rss
      });
      
      // Update max values
      this.metrics.resources.memory.maxHeapUsed = Math.max(
        this.metrics.resources.memory.maxHeapUsed,
        memUsage.heapUsed
      );
      this.metrics.resources.memory.maxHeapTotal = Math.max(
        this.metrics.resources.memory.maxHeapTotal,
        memUsage.heapTotal
      );
      this.metrics.resources.memory.maxExternal = Math.max(
        this.metrics.resources.memory.maxExternal,
        memUsage.external
      );
      this.metrics.resources.memory.maxRss = Math.max(
        this.metrics.resources.memory.maxRss,
        memUsage.rss
      );
      
      // Keep only last 100 entries for each metric
      ['heapUsed', 'heapTotal', 'external', 'rss'].forEach(metric => {
        if (this.metrics.resources.memory[metric].length > 100) {
          this.metrics.resources.memory[metric].shift();
        }
      });
      
      // CPU usage calculation (simplified)
      const cpuPercent = (cpuUsage.user + cpuUsage.system) / 1000000; // Convert microseconds to seconds
      this.metrics.resources.cpu.usage.push({
        timestamp: Date.now(),
        value: cpuPercent
      });
      this.metrics.resources.cpu.maxUsage = Math.max(
        this.metrics.resources.cpu.maxUsage,
        cpuPercent
      );
      
      if (this.metrics.resources.cpu.usage.length > 100) {
        this.metrics.resources.cpu.usage.shift();
      }
      
      // Memory alerts
      const memUsageMB = memUsage.heapUsed / 1024 / 1024;
      if (memUsageMB > 1000) { // > 1GB
        this.emitAlert('high_memory_usage', { 
          heapUsed: memUsageMB, 
          heapTotal: memUsage.heapTotal / 1024 / 1024 
        });
      }
      
      // Event loop lag measurement (simplified)
      const start = process.hrtime.bigint();
      setImmediate(() => {
        const lag = Number(process.hrtime.bigint() - start) / 1000000; // Convert to milliseconds
        this.metrics.resources.eventLoop.lag.push({
          timestamp: Date.now(),
          value: lag
        });
        this.metrics.resources.eventLoop.maxLag = Math.max(
          this.metrics.resources.eventLoop.maxLag,
          lag
        );
        
        if (this.metrics.resources.eventLoop.lag.length > 100) {
          this.metrics.resources.eventLoop.lag.shift();
        }
        
        // Alert on high event loop lag
        if (lag > 100) { // > 100ms
          this.emitAlert('high_event_loop_lag', { lag });
        }
      });
    };
    
    // Monitor every 5 seconds
    this.resourceMonitorInterval = setInterval(monitorResources, this.metrics.metadata.collectionInterval);
    
    // Initial measurement
    monitorResources();
  }

  /**
   * Start trend data collection
   */
  startTrendCollection() {
    const collectTrends = () => {
      const now = Date.now();
      
      // Calculate current rates
      const averageResponseTime = this.metrics.requests.total > 0 
        ? this.metrics.requests.totalResponseTime / this.metrics.requests.total 
        : 0;
      
      const errorRate = this.metrics.requests.total > 0 
        ? (this.metrics.requests.errorCount / this.metrics.requests.total) * 100 
        : 0;
      
      // Add to trend data
      this.addToTrend('responseTime', averageResponseTime);
      this.addToTrend('errorRate', errorRate);
      
      // Memory usage trend
      const currentMemory = this.metrics.resources.memory.heapUsed.length > 0
        ? this.metrics.resources.memory.heapUsed[this.metrics.resources.memory.heapUsed.length - 1].value
        : 0;
      this.addToTrend('memoryUsage', currentMemory / 1024 / 1024); // MB
      
      // CPU usage trend
      const currentCpu = this.metrics.resources.cpu.usage.length > 0
        ? this.metrics.resources.cpu.usage[this.metrics.resources.cpu.usage.length - 1].value
        : 0;
      this.addToTrend('cpuUsage', currentCpu);
    };
    
    // Collect trends every 5 minutes
    this.trendCollectionInterval = setInterval(collectTrends, 5 * 60 * 1000);
  }

  /**
   * Add data point to trend
   */
  addToTrend(trendName, value) {
    if (!this.metrics.trends[trendName]) {
      this.metrics.trends[trendName] = [];
    }
    
    this.metrics.trends[trendName].push({
      timestamp: Date.now(),
      value
    });
    
    // Keep only maxTrendSize entries
    if (this.metrics.trends[trendName].length > this.metrics.trends.maxTrendSize) {
      this.metrics.trends[trendName].shift();
    }
  }

  /**
   * Emit performance alert
   */
  emitAlert(type, data) {
    const alert = {
      type,
      data,
      timestamp: Date.now(),
      id: `alert_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
    };
    
    // Update alert metrics
    this.metrics.alerts.triggered++;
    const typeCount = this.metrics.alerts.byType.get(type) || 0;
    this.metrics.alerts.byType.set(type, typeCount + 1);
    
    // Add to recent alerts
    this.metrics.alerts.recent.push(alert);
    if (this.metrics.alerts.recent.length > this.metrics.alerts.maxRecent) {
      this.metrics.alerts.recent.shift();
    }
    
    // Emit event
    performanceEvents.emit('alert', alert);
    
    // Log alert
    ErrorLogger.logSecurityEvent('PERFORMANCE_ALERT', null, alert);
  }

  /**
   * Get comprehensive metrics
   */
  getMetrics() {
    return {
      ...this.metrics,
      computed: {
        uptime: Date.now() - this.metrics.metadata.startTime,
        averageResponseTime: this.metrics.requests.total > 0 
          ? this.metrics.requests.totalResponseTime / this.metrics.requests.total 
          : 0,
        requestRate: this.calculateRequestRate(),
        errorRate: this.metrics.requests.total > 0 
          ? (this.metrics.requests.errorCount / this.metrics.requests.total) * 100 
          : 0,
        slowRequestRate: this.metrics.requests.total > 0 
          ? (this.metrics.requests.slowCount / this.metrics.requests.total) * 100 
          : 0,
        dbQueryRate: this.calculateDbQueryRate(),
        cacheHitRate: this.metrics.cache.performance.averageHitRate,
        currentMemoryUsageMB: this.getCurrentMemoryUsage(),
        currentCpuUsage: this.getCurrentCpuUsage(),
        currentEventLoopLag: this.getCurrentEventLoopLag()
      }
    };
  }

  /**
   * Calculate current request rate (requests per minute)
   */
  calculateRequestRate() {
    const now = Date.now();
    const oneMinuteAgo = now - 60000;
    let recentRequests = 0;
    
    // This is simplified - in production you'd want more sophisticated rate calculation
    this.metrics.requests.byEndpoint.forEach(endpointMetrics => {
      endpointMetrics.recentRequests.forEach(request => {
        if (request.timestamp > oneMinuteAgo) {
          recentRequests++;
        }
      });
    });
    
    return recentRequests;
  }

  /**
   * Calculate database query rate (queries per minute)
   */
  calculateDbQueryRate() {
    // Simplified calculation - in production you'd track timestamps
    const uptime = (Date.now() - this.metrics.metadata.startTime) / 1000 / 60; // minutes
    return uptime > 0 ? this.metrics.database.queries.total / uptime : 0;
  }

  /**
   * Get current memory usage in MB
   */
  getCurrentMemoryUsage() {
    const current = this.metrics.resources.memory.heapUsed;
    return current.length > 0 ? current[current.length - 1].value / 1024 / 1024 : 0;
  }

  /**
   * Get current CPU usage
   */
  getCurrentCpuUsage() {
    const current = this.metrics.resources.cpu.usage;
    return current.length > 0 ? current[current.length - 1].value : 0;
  }

  /**
   * Get current event loop lag
   */
  getCurrentEventLoopLag() {
    const current = this.metrics.resources.eventLoop.lag;
    return current.length > 0 ? current[current.length - 1].value : 0;
  }

  /**
   * Reset metrics
   */
  reset() {
    // Clear intervals
    if (this.resourceMonitorInterval) {
      clearInterval(this.resourceMonitorInterval);
    }
    if (this.trendCollectionInterval) {
      clearInterval(this.trendCollectionInterval);
    }
    
    // Reset all metrics
    this.metrics = {
      requests: {
        total: 0,
        active: 0,
        slowCount: 0,
        verySlowCount: 0,
        errorCount: 0,
        totalResponseTime: 0,
        byEndpoint: new Map(),
        byStatusCode: new Map(),
        byUserAgent: new Map(),
        byIpAddress: new Map()
      },
      resources: {
        memory: {
          heapUsed: [],
          heapTotal: [],
          external: [],
          rss: [],
          maxHeapUsed: 0,
          maxHeapTotal: 0,
          maxExternal: 0,
          maxRss: 0
        },
        cpu: {
          usage: [],
          maxUsage: 0
        },
        eventLoop: {
          lag: [],
          maxLag: 0
        }
      },
      database: {
        queries: {
          total: 0,
          slow: 0,
          verySlow: 0,
          errors: 0,
          totalTime: 0,
          byTable: new Map(),
          byOperation: new Map(),
          connectionPool: {
            active: 0,
            idle: 0,
            waiting: 0,
            max: 0
          }
        }
      },
      cache: {
        operations: {
          total: 0,
          hits: 0,
          misses: 0,
          invalidations: 0,
          errors: 0
        },
        performance: {
          hitRateHistory: [],
          averageHitRate: 0
        }
      },
      alerts: {
        triggered: 0,
        byType: new Map(),
        recent: [],
        maxRecent: 100
      },
      trends: {
        responseTime: [],
        requestRate: [],
        errorRate: [],
        memoryUsage: [],
        cpuUsage: [],
        maxTrendSize: 288
      },
      metadata: {
        startTime: Date.now(),
        lastReset: Date.now(),
        collectionInterval: 5000,
        samplingRate: 1.0
      }
    };
    
    // Restart monitoring
    this.startResourceMonitoring();
    this.startTrendCollection();
  }

  /**
   * Cleanup resources
   */
  cleanup() {
    if (this.resourceMonitorInterval) {
      clearInterval(this.resourceMonitorInterval);
    }
    if (this.trendCollectionInterval) {
      clearInterval(this.trendCollectionInterval);
    }
  }
}

// Global metrics instance
const advancedMetrics = new AdvancedPerformanceMetrics();

/**
 * Advanced performance monitoring middleware
 */
function advancedPerformanceMonitor(options = {}) {
  const {
    slowThreshold = 1000,
    verySlowThreshold = 5000,
    trackMemory = true,
    trackCpu = true,
    enableAlerting = true,
    samplingRate = 1.0,
    excludeEndpoints = [],
    trackUserAgents = true,
    trackIpAddresses = true
  } = options;

  return (req, res, next) => {
    // Skip monitoring for excluded endpoints
    const endpoint = `${req.method} ${req.path}`;
    if (excludeEndpoints.some(pattern => endpoint.includes(pattern))) {
      return next();
    }
    
    // Apply sampling
    if (Math.random() > samplingRate) {
      return next();
    }
    
    const startTime = process.hrtime.bigint();
    const startMemory = process.memoryUsage();
    
    // Track active requests
    advancedMetrics.metrics.requests.active++;
    
    // Override res.end to capture completion metrics
    const originalEnd = res.end;
    let ended = false;
    
    res.end = function(...args) {
      if (ended) return;
      ended = true;
      
      const endTime = process.hrtime.bigint();
      const responseTime = Number(endTime - startTime) / 1000000; // Convert to milliseconds
      const endMemory = process.memoryUsage();
      
      // Track active requests
      advancedMetrics.metrics.requests.active--;
      
      // Record request metrics
      advancedMetrics.recordRequest(req, res, responseTime, res.locals.error);
      
      // Track memory delta if enabled
      if (trackMemory) {
        const memoryDelta = endMemory.heapUsed - startMemory.heapUsed;
        if (memoryDelta > 10 * 1024 * 1024) { // > 10MB increase
          advancedMetrics.emitAlert('high_memory_delta', {
            endpoint,
            memoryDelta: memoryDelta / 1024 / 1024, // MB
            responseTime
          });
        }
      }
      
      // Set performance headers
      res.set('X-Response-Time', `${responseTime.toFixed(2)}ms`);
      res.set('X-Memory-Delta', `${((endMemory.heapUsed - startMemory.heapUsed) / 1024).toFixed(2)}KB`);
      res.set('X-Request-ID', req.requestId || 'unknown');
      
      return originalEnd.apply(this, args);
    };
    
    // Track errors
    res.on('error', (error) => {
      res.locals.error = error;
      advancedMetrics.emitAlert('request_error', {
        endpoint,
        error: error.message,
        statusCode: res.statusCode
      });
    });
    
    next();
  };
}

/**
 * Database query performance monitoring wrapper
 */
function wrapDatabaseQuery(db) {
  const originalRaw = db.raw;
  const originalQuery = db.query;
  
  // Wrap raw queries
  db.raw = function(sql, bindings) {
    const startTime = process.hrtime.bigint();
    
    const result = originalRaw.call(this, sql, bindings);
    
    if (result &amp;&amp; typeof result.then === 'function') {
      return result
        .then(data => {
          const endTime = process.hrtime.bigint();
          const duration = Number(endTime - startTime) / 1000000; // milliseconds
          
          // Extract table and operation from SQL
          const { table, operation } = parseSqlQuery(sql);
          
          advancedMetrics.recordDbQuery(duration, sql, table, operation, false);
          return data;
        })
        .catch(error => {
          const endTime = process.hrtime.bigint();
          const duration = Number(endTime - startTime) / 1000000;
          
          const { table, operation } = parseSqlQuery(sql);
          
          advancedMetrics.recordDbQuery(duration, sql, table, operation, false, error);
          throw error;
        });
    }
    
    return result;
  };
  
  return db;
}

/**
 * Parse SQL query to extract table and operation
 */
function parseSqlQuery(sql) {
  if (!sql || typeof sql !== 'string') {
    return { table: 'unknown', operation: 'unknown' };
  }
  
  const cleanSql = sql.toLowerCase().trim();
  
  // Extract operation
  let operation = 'unknown';
  if (cleanSql.startsWith('select')) operation = 'select';
  else if (cleanSql.startsWith('insert')) operation = 'insert';
  else if (cleanSql.startsWith('update')) operation = 'update';
  else if (cleanSql.startsWith('delete')) operation = 'delete';
  else if (cleanSql.startsWith('create')) operation = 'create';
  else if (cleanSql.startsWith('drop')) operation = 'drop';
  else if (cleanSql.startsWith('alter')) operation = 'alter';
  
  // Extract table name (simplified)
  let table = 'unknown';
  const tablePatterns = [
    /(?:from|into|update|join)\s+["`]?(\w+)["`]?/i,
    /(?:table\s+)["`]?(\w+)["`]?/i
  ];
  
  for (const pattern of tablePatterns) {
    const match = sql.match(pattern);
    if (match &amp;&amp; match[1]) {
      table = match[1];
      break;
    }
  }
  
  return { table, operation };
}

/**
 * Get performance alert event emitter
 */
function getPerformanceEvents() {
  return performanceEvents;
}

/**
 * Get advanced metrics
 */
function getAdvancedMetrics() {
  return advancedMetrics.getMetrics();
}

/**
 * Reset advanced metrics
 */
function resetAdvancedMetrics() {
  advancedMetrics.reset();
}

/**
 * Setup performance alert handlers
 */
function setupAlertHandlers() {
  performanceEvents.on('alert', (alert) => {
    console.warn(`[PERFORMANCE ALERT] ${alert.type}:`, JSON.stringify(alert.data, null, 2));
    
    // Here you could integrate with external alerting systems
    // Examples: Slack, email, PagerDuty, etc.
    if (process.env.PERFORMANCE_ALERTS_WEBHOOK) {
      // Send to webhook
      sendAlertToWebhook(alert);
    }
  });
}

/**
 * Send alert to external webhook (placeholder)
 */
async function sendAlertToWebhook(alert) {
  try {
    // This would make an HTTP request to your alerting system
    // Implementation depends on your specific alerting needs
    console.log('Would send alert to webhook:', alert);
  } catch (error) {
    console.error('Failed to send performance alert to webhook:', error);
  }
}

/**
 * Cleanup on process exit
 */
process.on('exit', () => {
  advancedMetrics.cleanup();
});

process.on('SIGINT', () => {
  advancedMetrics.cleanup();
  process.exit(0);
});

process.on('SIGTERM', () => {
  advancedMetrics.cleanup();
  process.exit(0);
});

module.exports = {
  advancedPerformanceMonitor,
  wrapDatabaseQuery,
  getPerformanceEvents,
  getAdvancedMetrics,
  resetAdvancedMetrics,
  setupAlertHandlers,
  AdvancedPerformanceMetrics
};</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-routes_assignments.html">routes/assignments</a></li><li><a href="module-routes_games.html">routes/games</a></li></ul><h3>Classes</h3><ul><li><a href="AdvancedPerformanceMetrics.html">AdvancedPerformanceMetrics</a></li><li><a href="ApiError.html">ApiError</a></li><li><a href="AppError.html">AppError</a></li><li><a href="ApprovalWorkflowService.html">ApprovalWorkflowService</a></li><li><a href="AuthenticationError.html">AuthenticationError</a></li><li><a href="AuthorizationError.html">AuthorizationError</a></li><li><a href="global.html#BaseService">BaseService</a></li><li><a href="BudgetCalculationService.html">BudgetCalculationService</a></li><li><a href="BusinessLogicError.html">BusinessLogicError</a></li><li><a href="ConfigurationError.html">ConfigurationError</a></li><li><a href="ConflictError.html">ConflictError</a></li><li><a href="DatabaseError.html">DatabaseError</a></li><li><a href="DistanceCalculationService.html">DistanceCalculationService</a></li><li><a href="EncryptionService.html">EncryptionService</a></li><li><a href="ErrorFactory.html">ErrorFactory</a></li><li><a href="ErrorLogger.html">ErrorLogger</a></li><li><a href="ErrorMetrics.html">ErrorMetrics</a></li><li><a href="ErrorUtils.html">ErrorUtils</a></li><li><a href="ExternalServiceError.html">ExternalServiceError</a></li><li><a href="FileProcessingError.html">FileProcessingError</a></li><li><a href="FinancialAIService.html">FinancialAIService</a></li><li><a href="LocationDataService.html">LocationDataService</a></li><li><a href="MetricsCollector.html">MetricsCollector</a></li><li><a href="NotFoundError.html">NotFoundError</a></li><li><a href="PaymentMethodService.html">PaymentMethodService</a></li><li><a href="QueryBuilder.html">QueryBuilder</a></li><li><a href="QueryCache.html">QueryCache</a></li><li><a href="QueryPerformanceAnalyzer.html">QueryPerformanceAnalyzer</a></li><li><a href="RateLimitError.html">RateLimitError</a></li><li><a href="ResponseFormatter.html">ResponseFormatter</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="ServiceFactory.html">ServiceFactory</a></li><li><a href="TimeoutError.html">TimeoutError</a></li><li><a href="UnprocessableEntityError.html">UnprocessableEntityError</a></li><li><a href="ValidationError.html">ValidationError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AUDIT_EVENTS">AUDIT_EVENTS</a></li><li><a href="global.html#AUDIT_SEVERITY">AUDIT_SEVERITY</a></li><li><a href="global.html#AssignmentSchemas">AssignmentSchemas</a></li><li><a href="global.html#AuthSchemas">AuthSchemas</a></li><li><a href="global.html#AvailabilitySchemas">AvailabilitySchemas</a></li><li><a href="global.html#BaseSchemas">BaseSchemas</a></li><li><a href="global.html#BudgetSchemas">BudgetSchemas</a></li><li><a href="global.html#COMMON_PATTERNS">COMMON_PATTERNS</a></li><li><a href="global.html#CUSTOM_VALIDATORS">CUSTOM_VALIDATORS</a></li><li><a href="global.html#CacheHelpers">CacheHelpers</a></li><li><a href="global.html#CacheInvalidation">CacheInvalidation</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#ERROR_SEVERITY">ERROR_SEVERITY</a></li><li><a href="global.html#ERROR_TYPES">ERROR_TYPES</a></li><li><a href="global.html#FileSchemas">FileSchemas</a></li><li><a href="global.html#FilterSchemas">FilterSchemas</a></li><li><a href="global.html#GameSchemas">GameSchemas</a></li><li><a href="global.html#HTTP_STATUS">HTTP_STATUS</a></li><li><a href="global.html#IdParamSchema">IdParamSchema</a></li><li><a href="global.html#NodeCache">NodeCache</a></li><li><a href="global.html#PaginationSchema">PaginationSchema</a></li><li><a href="global.html#QueryHelpers">QueryHelpers</a></li><li><a href="global.html#SCHEMA_REGISTRY">SCHEMA_REGISTRY</a></li><li><a href="global.html#UserSchemas">UserSchemas</a></li><li><a href="global.html#VALIDATION_OPTIONS">VALIDATION_OPTIONS</a></li><li><a href="global.html#addMinutes">addMinutes</a></li><li><a href="global.html#advancedPerformanceMonitor">advancedPerformanceMonitor</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#auditMiddleware">auditMiddleware</a></li><li><a href="global.html#authLimiter">authLimiter</a></li><li><a href="global.html#autoValidate">autoValidate</a></li><li><a href="global.html#calculateAvailabilityScore">calculateAvailabilityScore</a></li><li><a href="global.html#calculateDatabaseHealthScore">calculateDatabaseHealthScore</a></li><li><a href="global.html#calculateEndTime">calculateEndTime</a></li><li><a href="global.html#calculateFinalWage">calculateFinalWage</a></li><li><a href="global.html#checkAssignmentConflicts">checkAssignmentConflicts</a></li><li><a href="global.html#checkGameSchedulingConflicts">checkGameSchedulingConflicts</a></li><li><a href="global.html#checkRefereeDoubleBooking">checkRefereeDoubleBooking</a></li><li><a href="global.html#checkServiceHealth">checkServiceHealth</a></li><li><a href="global.html#checkTimeOverlap">checkTimeOverlap</a></li><li><a href="global.html#checkTravelTimeConflict">checkTravelTimeConflict</a></li><li><a href="global.html#checkVenueConflict">checkVenueConflict</a></li><li><a href="global.html#clearSettingsCache">clearSettingsCache</a></li><li><a href="global.html#conditionalValidation">conditionalValidation</a></li><li><a href="global.html#createAuditLog">createAuditLog</a></li><li><a href="global.html#createAuditLogsTable">createAuditLogsTable</a></li><li><a href="global.html#createPerformanceRoute">createPerformanceRoute</a></li><li><a href="global.html#createSecurityMiddleware">createSecurityMiddleware</a></li><li><a href="global.html#createTableService">createTableService</a></li><li><a href="global.html#createValidationError">createValidationError</a></li><li><a href="global.html#createValidator">createValidator</a></li><li><a href="global.html#db">db</a></li><li><a href="global.html#determineErrorSeverity">determineErrorSeverity</a></li><li><a href="global.html#determineEventType">determineEventType</a></li><li><a href="global.html#determineHealthStatus">determineHealthStatus</a></li><li><a href="global.html#determineIfShouldLog">determineIfShouldLog</a></li><li><a href="global.html#determineSeverity">determineSeverity</a></li><li><a href="global.html#enforceHTTPS">enforceHTTPS</a></li><li><a href="global.html#enhancedAsyncHandler">enhancedAsyncHandler</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#errorHealthCheck">errorHealthCheck</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#findAvailableReferees">findAvailableReferees</a></li><li><a href="global.html#formatAvailabilityResponse">formatAvailabilityResponse</a></li><li><a href="global.html#formatBytes">formatBytes</a></li><li><a href="global.html#generateAdvancedRecommendations">generateAdvancedRecommendations</a></li><li><a href="global.html#generateCacheRecommendations">generateCacheRecommendations</a></li><li><a href="global.html#generateDatabaseInsights">generateDatabaseInsights</a></li><li><a href="global.html#generateGroupStagePlayoffs">generateGroupStagePlayoffs</a></li><li><a href="global.html#generateHealthRecommendations">generateHealthRecommendations</a></li><li><a href="global.html#generateRecommendations">generateRecommendations</a></li><li><a href="global.html#generateRoundRobin">generateRoundRobin</a></li><li><a href="global.html#generateSingleElimination">generateSingleElimination</a></li><li><a href="global.html#generateSwissSystem">generateSwissSystem</a></li><li><a href="global.html#generateTransactionNumber">generateTransactionNumber</a></li><li><a href="global.html#getAdvancedMetrics">getAdvancedMetrics</a></li><li><a href="global.html#getAggregatedMetrics">getAggregatedMetrics</a></li><li><a href="global.html#getAuditEventType">getAuditEventType</a></li><li><a href="global.html#getClientIP">getClientIP</a></li><li><a href="global.html#getCorsConfig">getCorsConfig</a></li><li><a href="global.html#getErrorMessage">getErrorMessage</a></li><li><a href="global.html#getMetricsCollector">getMetricsCollector</a></li><li><a href="global.html#getMetricsEvents">getMetricsEvents</a></li><li><a href="global.html#getMetricsSummary">getMetricsSummary</a></li><li><a href="global.html#getMinutesBetween">getMinutesBetween</a></li><li><a href="global.html#getOrganizationSettings">getOrganizationSettings</a></li><li><a href="global.html#getPerformanceEvents">getPerformanceEvents</a></li><li><a href="global.html#getPerformanceStats">getPerformanceStats</a></li><li><a href="global.html#getQueryPerformanceEvents">getQueryPerformanceEvents</a></li><li><a href="global.html#getQueryPerformanceStats">getQueryPerformanceStats</a></li><li><a href="global.html#getSecurityConfig">getSecurityConfig</a></li><li><a href="global.html#getService">getService</a></li><li><a href="global.html#getServices">getServices</a></li><li><a href="global.html#getSlowQueriesSummary">getSlowQueriesSummary</a></li><li><a href="global.html#getWageBreakdown">getWageBreakdown</a></li><li><a href="global.html#handleApprovedRequest">handleApprovedRequest</a></li><li><a href="global.html#handleDatabaseError">handleDatabaseError</a></li><li><a href="global.html#hasSchedulingConflict">hasSchedulingConflict</a></li><li><a href="global.html#initializeServices">initializeServices</a></li><li><a href="global.html#knex">knex</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#logRequest">logRequest</a></li><li><a href="global.html#logSuspiciousActivity">logSuspiciousActivity</a></li><li><a href="global.html#logUnauthorizedCorsAttempt">logUnauthorizedCorsAttempt</a></li><li><a href="global.html#metricsEvents">metricsEvents</a></li><li><a href="global.html#notFoundHandler">notFoundHandler</a></li><li><a href="global.html#parseSize">parseSize</a></li><li><a href="global.html#parseSqlQuery">parseSqlQuery</a></li><li><a href="global.html#performanceEvents">performanceEvents</a></li><li><a href="global.html#performanceMonitor">performanceMonitor</a></li><li><a href="global.html#queryAuditLogs">queryAuditLogs</a></li><li><a href="global.html#queryCache">queryCache</a></li><li><a href="global.html#queryPerformanceEvents">queryPerformanceEvents</a></li><li><a href="global.html#queryValidationSchemas">queryValidationSchemas</a></li><li><a href="global.html#requestContextMiddleware">requestContextMiddleware</a></li><li><a href="global.html#requestContexts">requestContexts</a></li><li><a href="global.html#requestSizeLimit">requestSizeLimit</a></li><li><a href="global.html#resetAdvancedMetrics">resetAdvancedMetrics</a></li><li><a href="global.html#resetAllMetrics">resetAllMetrics</a></li><li><a href="global.html#resetPerformanceStats">resetPerformanceStats</a></li><li><a href="global.html#resetQueryPerformanceStats">resetQueryPerformanceStats</a></li><li><a href="global.html#sanitizeAll">sanitizeAll</a></li><li><a href="global.html#sanitizeBody">sanitizeBody</a></li><li><a href="global.html#sanitizeBodyForLogging">sanitizeBodyForLogging</a></li><li><a href="global.html#sanitizeError">sanitizeError</a></li><li><a href="global.html#sanitizeHeaders">sanitizeHeaders</a></li><li><a href="global.html#sanitizeInput">sanitizeInput</a></li><li><a href="global.html#sanitizeObject">sanitizeObject</a></li><li><a href="global.html#sanitizeParams">sanitizeParams</a></li><li><a href="global.html#sanitizeQuery">sanitizeQuery</a></li><li><a href="global.html#sanitizeString">sanitizeString</a></li><li><a href="global.html#securityConfig">securityConfig</a></li><li><a href="global.html#securityMonitoring">securityMonitoring</a></li><li><a href="global.html#sendAlertToWebhook">sendAlertToWebhook</a></li><li><a href="global.html#setupAlertHandlers">setupAlertHandlers</a></li><li><a href="global.html#setupGlobalErrorHandlers">setupGlobalErrorHandlers</a></li><li><a href="global.html#subtractMinutes">subtractMinutes</a></li><li><a href="global.html#testIntegrationConnection">testIntegrationConnection</a></li><li><a href="global.html#trackCacheOperation">trackCacheOperation</a></li><li><a href="global.html#trackDbQuery">trackDbQuery</a></li><li><a href="global.html#updateMetricsConfig">updateMetricsConfig</a></li><li><a href="global.html#validateAvailabilityWindow">validateAvailabilityWindow</a></li><li><a href="global.html#validateBody">validateBody</a></li><li><a href="global.html#validateContentType">validateContentType</a></li><li><a href="global.html#validateEnvironment">validateEnvironment</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateIdParam">validateIdParam</a></li><li><a href="global.html#validateParams">validateParams</a></li><li><a href="global.html#validateQuery">validateQuery</a></li><li><a href="global.html#validateRefereeQualifications">validateRefereeQualifications</a></li><li><a href="global.html#validateRequest">validateRequest</a></li><li><a href="global.html#validateUuidParam">validateUuidParam</a></li><li><a href="global.html#validationSummary">validationSummary</a></li><li><a href="global.html#withDatabaseError">withDatabaseError</a></li><li><a href="global.html#withErrorBoundary">withErrorBoundary</a></li><li><a href="global.html#withServiceTransaction">withServiceTransaction</a></li><li><a href="global.html#wrapDatabaseConnection">wrapDatabaseConnection</a></li><li><a href="global.html#wrapDatabaseQuery">wrapDatabaseQuery</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 01 2025 16:15:52 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
