<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: services/SecurityService.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: services/SecurityService.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const { v4: uuidv4 } = require('uuid');
const knex = require('../config/database');
const EncryptionService = require('./EncryptionService');
const AuditService = require('./AuditService');

/**
 * Core Security Service for enterprise-grade security operations
 * Handles authentication, authorization, session management, and security monitoring
 */
class SecurityService {
  constructor() {
    this.encryptionService = new EncryptionService();
    this.auditService = new AuditService();
    this.maxLoginAttempts = 5;
    this.lockoutDuration = 15 * 60 * 1000; // 15 minutes
    this.sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours
    this.refreshTokenTimeout = 7 * 24 * 60 * 60 * 1000; // 7 days
  }

  /**
   * Enhanced user authentication with security monitoring
   */
  async authenticateUser(email, password, ipAddress, userAgent, additionalData = {}) {
    const startTime = Date.now();
    let user = null;
    let loginSuccessful = false;
    let failureReason = null;

    try {
      // Check for account lockout
      const isLocked = await this.isAccountLocked(email, ipAddress);
      if (isLocked) {
        failureReason = 'account_locked';
        await this.logLoginAttempt(email, ipAddress, false, failureReason, userAgent);
        throw new Error('Account temporarily locked due to too many failed attempts');
      }

      // Find user
      user = await knex('users').where({ email }).first();
      if (!user) {
        failureReason = 'user_not_found';
        await this.logLoginAttempt(email, ipAddress, false, failureReason, userAgent);
        throw new Error('Invalid credentials');
      }

      // Verify password
      const passwordValid = await bcrypt.compare(password, user.password);
      if (!passwordValid) {
        failureReason = 'invalid_password';
        await this.logLoginAttempt(email, ipAddress, false, failureReason, userAgent);
        throw new Error('Invalid credentials');
      }

      loginSuccessful = true;

      // Check if MFA is enabled
      const mfaSettings = await this.getMFASettings(user.id);
      if (mfaSettings &amp;&amp; mfaSettings.is_enabled) {
        return {
          success: true,
          requiresMFA: true,
          userId: user.id,
          mfaMethod: mfaSettings.method
        };
      }

      // Create session
      const session = await this.createUserSession(user, ipAddress, userAgent, additionalData);
      
      // Log successful login
      await this.logLoginAttempt(email, ipAddress, true, null, userAgent);
      
      // Create security event
      await this.createSecurityEvent({
        userId: user.id,
        eventType: 'successful_login',
        severity: 'low',
        ipAddress,
        userAgent,
        eventData: {
          loginDuration: Date.now() - startTime,
          mfaEnabled: false,
          ...additionalData
        }
      });

      return {
        success: true,
        user: this.sanitizeUser(user),
        session,
        tokens: {
          accessToken: session.session_token,
          refreshToken: session.refresh_token
        }
      };

    } catch (error) {
      // Log failed login attempt
      if (!loginSuccessful) {
        await this.logLoginAttempt(email, ipAddress, false, failureReason || 'unknown_error', userAgent);
        
        // Create security event for failed login
        await this.createSecurityEvent({
          userId: user?.id || null,
          eventType: 'failed_login',
          severity: 'medium',
          ipAddress,
          userAgent,
          eventData: {
            email,
            reason: failureReason,
            duration: Date.now() - startTime
          }
        });
      }

      throw error;
    }
  }

  /**
   * Complete MFA authentication
   */
  async completeMFAAuthentication(userId, mfaCode, ipAddress, userAgent) {
    try {
      const user = await knex('users').where({ id: userId }).first();
      if (!user) {
        throw new Error('User not found');
      }

      const mfaSettings = await this.getMFASettings(userId);
      if (!mfaSettings || !mfaSettings.is_enabled) {
        throw new Error('MFA not enabled for this user');
      }

      // Verify MFA code
      const isValidCode = await this.verifyMFACode(userId, mfaCode, mfaSettings.method);
      if (!isValidCode) {
        await this.incrementMFAFailedAttempts(userId);
        
        await this.createSecurityEvent({
          userId,
          eventType: 'mfa_failed',
          severity: 'high',
          ipAddress,
          userAgent,
          eventData: { method: mfaSettings.method }
        });

        throw new Error('Invalid MFA code');
      }

      // Reset failed attempts
      await this.resetMFAFailedAttempts(userId);

      // Create session
      const session = await this.createUserSession(user, ipAddress, userAgent, { mfaCompleted: true });

      // Log successful MFA completion
      await this.createSecurityEvent({
        userId,
        eventType: 'mfa_completed',
        severity: 'low',
        ipAddress,
        userAgent,
        eventData: { method: mfaSettings.method }
      });

      return {
        success: true,
        user: this.sanitizeUser(user),
        session,
        tokens: {
          accessToken: session.session_token,
          refreshToken: session.refresh_token
        }
      };

    } catch (error) {
      throw error;
    }
  }

  /**
   * Create a new user session with enhanced security
   */
  async createUserSession(user, ipAddress, userAgent, additionalData = {}) {
    const sessionId = uuidv4();
    const sessionToken = this.generateSecureToken();
    const refreshToken = this.generateSecureToken();
    
    const expiresAt = new Date(Date.now() + this.sessionTimeout);
    const refreshExpiresAt = new Date(Date.now() + this.refreshTokenTimeout);

    // Create device fingerprint
    const deviceFingerprint = this.createDeviceFingerprint(userAgent, additionalData);

    const session = {
      id: sessionId,
      user_id: user.id,
      session_token: sessionToken,
      refresh_token: refreshToken,
      device_fingerprint: deviceFingerprint,
      ip_address: ipAddress,
      user_agent: userAgent,
      location_data: additionalData.location || null,
      expires_at: expiresAt,
      last_activity: new Date(),
      created_at: new Date()
    };

    await knex('user_sessions').insert(session);

    // Create JWT tokens with additional security claims
    const accessToken = jwt.sign(
      {
        userId: user.id,
        sessionId,
        email: user.email,
        roles: user.roles || [user.role],
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(expiresAt.getTime() / 1000),
        deviceFingerprint
      },
      process.env.JWT_SECRET
    );

    const refreshTokenJWT = jwt.sign(
      {
        userId: user.id,
        sessionId,
        type: 'refresh',
        iat: Math.floor(Date.now() / 1000),
        exp: Math.floor(refreshExpiresAt.getTime() / 1000)
      },
      process.env.JWT_SECRET
    );

    return {
      ...session,
      session_token: accessToken,
      refresh_token: refreshTokenJWT
    };
  }

  /**
   * Validate and refresh JWT token
   */
  async refreshToken(refreshTokenJWT, ipAddress, userAgent) {
    try {
      const decoded = jwt.verify(refreshTokenJWT, process.env.JWT_SECRET);
      
      if (decoded.type !== 'refresh') {
        throw new Error('Invalid token type');
      }

      const session = await knex('user_sessions')
        .where({ 
          id: decoded.sessionId,
          user_id: decoded.userId,
          is_active: true
        })
        .first();

      if (!session) {
        throw new Error('Session not found');
      }

      if (new Date() > new Date(session.expires_at)) {
        await this.invalidateSession(session.id);
        throw new Error('Session expired');
      }

      const user = await knex('users').where({ id: decoded.userId }).first();
      if (!user) {
        throw new Error('User not found');
      }

      // Create new session
      const newSession = await this.createUserSession(user, ipAddress, userAgent);

      // Invalidate old session
      await this.invalidateSession(session.id);

      return {
        success: true,
        tokens: {
          accessToken: newSession.session_token,
          refreshToken: newSession.refresh_token
        }
      };

    } catch (error) {
      throw error;
    }
  }

  /**
   * Check if account is locked due to failed attempts
   */
  async isAccountLocked(identifier, ipAddress) {
    const recentAttempts = await knex('login_attempts')
      .where('identifier', identifier)
      .orWhere('ip_address', ipAddress)
      .where('attempted_at', '>', new Date(Date.now() - this.lockoutDuration))
      .where('successful', false)
      .count('* as count')
      .first();

    return parseInt(recentAttempts.count) >= this.maxLoginAttempts;
  }

  /**
   * Log login attempt for security monitoring
   */
  async logLoginAttempt(identifier, ipAddress, successful, failureReason = null, userAgent = null) {
    await knex('login_attempts').insert({
      identifier,
      ip_address: ipAddress,
      successful,
      failure_reason: failureReason,
      user_agent: userAgent,
      attempted_at: new Date()
    });
  }

  /**
   * Create security event for monitoring
   */
  async createSecurityEvent(eventData) {
    const {
      userId,
      eventType,
      severity,
      ipAddress,
      userAgent,
      eventData: data,
      riskScore = null
    } = eventData;

    const event = {
      id: uuidv4(),
      user_id: userId,
      event_type: eventType,
      severity,
      ip_address: ipAddress,
      user_agent: userAgent,
      event_data: JSON.stringify(data),
      risk_score: riskScore,
      created_at: new Date()
    };

    await knex('security_events').insert(event);

    // Check if this event requires immediate attention
    if (severity === 'critical' || severity === 'high') {
      await this.handleHighSeverityEvent(event);
    }

    return event;
  }

  /**
   * Handle high severity security events
   */
  async handleHighSeverityEvent(event) {
    // Create security incident if needed
    if (event.severity === 'critical') {
      await this.createSecurityIncident({
        title: `Critical Security Event: ${event.event_type}`,
        description: `Automated incident created for critical security event`,
        severity: 'critical',
        affectedUserId: event.user_id,
        eventData: event
      });
    }

    // Additional automated responses can be added here
    // e.g., account lockout, admin notifications, etc.
  }

  /**
   * Create security incident
   */
  async createSecurityIncident(incidentData) {
    const {
      title,
      description,
      severity,
      affectedUserId = null,
      affectedResources = null,
      eventData = null
    } = incidentData;

    const incident = {
      id: uuidv4(),
      title,
      description,
      severity,
      affected_user_id: affectedUserId,
      affected_resources: affectedResources ? JSON.stringify(affectedResources) : null,
      timeline: JSON.stringify([{
        timestamp: new Date(),
        event: 'Incident created',
        details: 'Automated incident creation based on security event'
      }]),
      evidence: eventData ? JSON.stringify([eventData]) : null,
      detected_at: new Date(),
      created_at: new Date()
    };

    await knex('security_incidents').insert(incident);
    return incident;
  }

  /**
   * Validate session and update activity
   */
  async validateSession(sessionToken, ipAddress = null) {
    try {
      const decoded = jwt.verify(sessionToken, process.env.JWT_SECRET);
      
      const session = await knex('user_sessions')
        .where({ 
          id: decoded.sessionId,
          user_id: decoded.userId,
          is_active: true 
        })
        .first();

      if (!session) {
        throw new Error('Session not found');
      }

      if (new Date() > new Date(session.expires_at)) {
        await this.invalidateSession(session.id);
        throw new Error('Session expired');
      }

      // Update last activity
      await knex('user_sessions')
        .where({ id: session.id })
        .update({ last_activity: new Date() });

      // Verify device fingerprint if available
      if (decoded.deviceFingerprint &amp;&amp; session.device_fingerprint) {
        if (decoded.deviceFingerprint !== session.device_fingerprint) {
          await this.createSecurityEvent({
            userId: decoded.userId,
            eventType: 'device_fingerprint_mismatch',
            severity: 'high',
            ipAddress: ipAddress || session.ip_address,
            userAgent: session.user_agent,
            eventData: {
              sessionId: session.id,
              expectedFingerprint: session.device_fingerprint,
              actualFingerprint: decoded.deviceFingerprint
            }
          });
        }
      }

      return {
        valid: true,
        session,
        user: decoded
      };

    } catch (error) {
      return {
        valid: false,
        error: error.message
      };
    }
  }

  /**
   * Invalidate user session
   */
  async invalidateSession(sessionId, reason = 'logout') {
    await knex('user_sessions')
      .where({ id: sessionId })
      .update({ 
        is_active: false,
        updated_at: new Date()
      });

    // Log session invalidation
    const session = await knex('user_sessions').where({ id: sessionId }).first();
    if (session) {
      await this.createSecurityEvent({
        userId: session.user_id,
        eventType: 'session_invalidated',
        severity: 'low',
        ipAddress: session.ip_address,
        userAgent: session.user_agent,
        eventData: {
          sessionId,
          reason,
          duration: new Date() - new Date(session.created_at)
        }
      });
    }
  }

  /**
   * Get user's active sessions
   */
  async getUserSessions(userId) {
    return await knex('user_sessions')
      .where({ 
        user_id: userId, 
        is_active: true 
      })
      .where('expires_at', '>', new Date())
      .orderBy('last_activity', 'desc');
  }

  /**
   * Clean up expired sessions
   */
  async cleanupExpiredSessions() {
    const expiredSessions = await knex('user_sessions')
      .where('expires_at', '&lt;', new Date())
      .where('is_active', true);

    for (const session of expiredSessions) {
      await this.invalidateSession(session.id, 'expired');
    }

    return expiredSessions.length;
  }

  /**
   * Generate secure random token
   */
  generateSecureToken(length = 32) {
    return crypto.randomBytes(length).toString('hex');
  }

  /**
   * Create device fingerprint
   */
  createDeviceFingerprint(userAgent, additionalData = {}) {
    const data = {
      userAgent,
      ...additionalData
    };
    
    return crypto
      .createHash('sha256')
      .update(JSON.stringify(data))
      .digest('hex');
  }

  /**
   * Sanitize user data for API responses
   */
  sanitizeUser(user) {
    const { password, ...sanitized } = user;
    return sanitized;
  }

  /**
   * Get MFA settings for user
   */
  async getMFASettings(userId) {
    return await knex('mfa_settings')
      .where({ user_id: userId, is_enabled: true })
      .first();
  }

  /**
   * Verify MFA code
   */
  async verifyMFACode(userId, code, method) {
    // Implementation depends on MFA method
    // This is a placeholder for the actual MFA verification logic
    return true; // Simplified for now
  }

  /**
   * Increment MFA failed attempts
   */
  async incrementMFAFailedAttempts(userId) {
    await knex('mfa_settings')
      .where({ user_id: userId })
      .increment('failed_attempts', 1);
  }

  /**
   * Reset MFA failed attempts
   */
  async resetMFAFailedAttempts(userId) {
    await knex('mfa_settings')
      .where({ user_id: userId })
      .update({ failed_attempts: 0, locked_until: null });
  }

  /**
   * Check user permissions
   */
  async checkPermission(userId, resource, action) {
    // Get user roles
    const user = await knex('users').where({ id: userId }).first();
    if (!user) return false;

    const userRoles = user.roles || [user.role];
    
    // Admin always has access
    if (userRoles.includes('admin')) return true;

    // Check role-based permissions
    const rolePermissions = await knex('role_permissions')
      .join('permissions', 'role_permissions.permission_id', 'permissions.id')
      .join('roles', 'role_permissions.role_id', 'roles.id')
      .whereIn('roles.name', userRoles)
      .where('permissions.resource', resource)
      .where('permissions.action', action)
      .where('permissions.is_active', true)
      .first();

    if (rolePermissions) return true;

    // Check user-specific permissions
    const userPermission = await knex('user_permissions')
      .join('permissions', 'user_permissions.permission_id', 'permissions.id')
      .where('user_permissions.user_id', userId)
      .where('permissions.resource', resource)
      .where('permissions.action', action)
      .where('permissions.is_active', true)
      .where(function() {
        this.whereNull('user_permissions.expires_at')
          .orWhere('user_permissions.expires_at', '>', new Date());
      })
      .first();

    return userPermission ? userPermission.granted : false;
  }
}

module.exports = SecurityService;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-routes_assignments.html">routes/assignments</a></li><li><a href="module-routes_games.html">routes/games</a></li></ul><h3>Classes</h3><ul><li><a href="AdvancedPerformanceMetrics.html">AdvancedPerformanceMetrics</a></li><li><a href="ApiError.html">ApiError</a></li><li><a href="AppError.html">AppError</a></li><li><a href="ApprovalWorkflowService.html">ApprovalWorkflowService</a></li><li><a href="AuthenticationError.html">AuthenticationError</a></li><li><a href="AuthorizationError.html">AuthorizationError</a></li><li><a href="global.html#BaseService">BaseService</a></li><li><a href="BudgetCalculationService.html">BudgetCalculationService</a></li><li><a href="BusinessLogicError.html">BusinessLogicError</a></li><li><a href="ConfigurationError.html">ConfigurationError</a></li><li><a href="ConflictError.html">ConflictError</a></li><li><a href="DatabaseError.html">DatabaseError</a></li><li><a href="DistanceCalculationService.html">DistanceCalculationService</a></li><li><a href="EncryptionService.html">EncryptionService</a></li><li><a href="ErrorFactory.html">ErrorFactory</a></li><li><a href="ErrorLogger.html">ErrorLogger</a></li><li><a href="ErrorMetrics.html">ErrorMetrics</a></li><li><a href="ErrorUtils.html">ErrorUtils</a></li><li><a href="ExternalServiceError.html">ExternalServiceError</a></li><li><a href="FileProcessingError.html">FileProcessingError</a></li><li><a href="FinancialAIService.html">FinancialAIService</a></li><li><a href="LocationDataService.html">LocationDataService</a></li><li><a href="MetricsCollector.html">MetricsCollector</a></li><li><a href="NotFoundError.html">NotFoundError</a></li><li><a href="PaymentMethodService.html">PaymentMethodService</a></li><li><a href="QueryBuilder.html">QueryBuilder</a></li><li><a href="QueryCache.html">QueryCache</a></li><li><a href="QueryPerformanceAnalyzer.html">QueryPerformanceAnalyzer</a></li><li><a href="RateLimitError.html">RateLimitError</a></li><li><a href="ResponseFormatter.html">ResponseFormatter</a></li><li><a href="SecurityService.html">SecurityService</a></li><li><a href="ServiceFactory.html">ServiceFactory</a></li><li><a href="TimeoutError.html">TimeoutError</a></li><li><a href="UnprocessableEntityError.html">UnprocessableEntityError</a></li><li><a href="ValidationError.html">ValidationError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#AUDIT_EVENTS">AUDIT_EVENTS</a></li><li><a href="global.html#AUDIT_SEVERITY">AUDIT_SEVERITY</a></li><li><a href="global.html#AssignmentSchemas">AssignmentSchemas</a></li><li><a href="global.html#AuthSchemas">AuthSchemas</a></li><li><a href="global.html#AvailabilitySchemas">AvailabilitySchemas</a></li><li><a href="global.html#BaseSchemas">BaseSchemas</a></li><li><a href="global.html#BudgetSchemas">BudgetSchemas</a></li><li><a href="global.html#COMMON_PATTERNS">COMMON_PATTERNS</a></li><li><a href="global.html#CUSTOM_VALIDATORS">CUSTOM_VALIDATORS</a></li><li><a href="global.html#CacheHelpers">CacheHelpers</a></li><li><a href="global.html#CacheInvalidation">CacheInvalidation</a></li><li><a href="global.html#ERROR_MESSAGES">ERROR_MESSAGES</a></li><li><a href="global.html#ERROR_SEVERITY">ERROR_SEVERITY</a></li><li><a href="global.html#ERROR_TYPES">ERROR_TYPES</a></li><li><a href="global.html#FileSchemas">FileSchemas</a></li><li><a href="global.html#FilterSchemas">FilterSchemas</a></li><li><a href="global.html#GameSchemas">GameSchemas</a></li><li><a href="global.html#HTTP_STATUS">HTTP_STATUS</a></li><li><a href="global.html#IdParamSchema">IdParamSchema</a></li><li><a href="global.html#NodeCache">NodeCache</a></li><li><a href="global.html#PaginationSchema">PaginationSchema</a></li><li><a href="global.html#QueryHelpers">QueryHelpers</a></li><li><a href="global.html#SCHEMA_REGISTRY">SCHEMA_REGISTRY</a></li><li><a href="global.html#UserSchemas">UserSchemas</a></li><li><a href="global.html#VALIDATION_OPTIONS">VALIDATION_OPTIONS</a></li><li><a href="global.html#addMinutes">addMinutes</a></li><li><a href="global.html#advancedPerformanceMonitor">advancedPerformanceMonitor</a></li><li><a href="global.html#asyncHandler">asyncHandler</a></li><li><a href="global.html#auditMiddleware">auditMiddleware</a></li><li><a href="global.html#authLimiter">authLimiter</a></li><li><a href="global.html#autoValidate">autoValidate</a></li><li><a href="global.html#calculateAvailabilityScore">calculateAvailabilityScore</a></li><li><a href="global.html#calculateDatabaseHealthScore">calculateDatabaseHealthScore</a></li><li><a href="global.html#calculateEndTime">calculateEndTime</a></li><li><a href="global.html#calculateFinalWage">calculateFinalWage</a></li><li><a href="global.html#checkAssignmentConflicts">checkAssignmentConflicts</a></li><li><a href="global.html#checkGameSchedulingConflicts">checkGameSchedulingConflicts</a></li><li><a href="global.html#checkRefereeDoubleBooking">checkRefereeDoubleBooking</a></li><li><a href="global.html#checkServiceHealth">checkServiceHealth</a></li><li><a href="global.html#checkTimeOverlap">checkTimeOverlap</a></li><li><a href="global.html#checkTravelTimeConflict">checkTravelTimeConflict</a></li><li><a href="global.html#checkVenueConflict">checkVenueConflict</a></li><li><a href="global.html#clearSettingsCache">clearSettingsCache</a></li><li><a href="global.html#conditionalValidation">conditionalValidation</a></li><li><a href="global.html#createAuditLog">createAuditLog</a></li><li><a href="global.html#createAuditLogsTable">createAuditLogsTable</a></li><li><a href="global.html#createPerformanceRoute">createPerformanceRoute</a></li><li><a href="global.html#createSecurityMiddleware">createSecurityMiddleware</a></li><li><a href="global.html#createTableService">createTableService</a></li><li><a href="global.html#createValidationError">createValidationError</a></li><li><a href="global.html#createValidator">createValidator</a></li><li><a href="global.html#db">db</a></li><li><a href="global.html#determineErrorSeverity">determineErrorSeverity</a></li><li><a href="global.html#determineEventType">determineEventType</a></li><li><a href="global.html#determineHealthStatus">determineHealthStatus</a></li><li><a href="global.html#determineIfShouldLog">determineIfShouldLog</a></li><li><a href="global.html#determineSeverity">determineSeverity</a></li><li><a href="global.html#enforceHTTPS">enforceHTTPS</a></li><li><a href="global.html#enhancedAsyncHandler">enhancedAsyncHandler</a></li><li><a href="global.html#errorHandler">errorHandler</a></li><li><a href="global.html#errorHealthCheck">errorHealthCheck</a></li><li><a href="global.html#express">express</a></li><li><a href="global.html#findAvailableReferees">findAvailableReferees</a></li><li><a href="global.html#formatAvailabilityResponse">formatAvailabilityResponse</a></li><li><a href="global.html#formatBytes">formatBytes</a></li><li><a href="global.html#generateAdvancedRecommendations">generateAdvancedRecommendations</a></li><li><a href="global.html#generateCacheRecommendations">generateCacheRecommendations</a></li><li><a href="global.html#generateDatabaseInsights">generateDatabaseInsights</a></li><li><a href="global.html#generateGroupStagePlayoffs">generateGroupStagePlayoffs</a></li><li><a href="global.html#generateHealthRecommendations">generateHealthRecommendations</a></li><li><a href="global.html#generateRecommendations">generateRecommendations</a></li><li><a href="global.html#generateRoundRobin">generateRoundRobin</a></li><li><a href="global.html#generateSingleElimination">generateSingleElimination</a></li><li><a href="global.html#generateSwissSystem">generateSwissSystem</a></li><li><a href="global.html#generateTransactionNumber">generateTransactionNumber</a></li><li><a href="global.html#getAdvancedMetrics">getAdvancedMetrics</a></li><li><a href="global.html#getAggregatedMetrics">getAggregatedMetrics</a></li><li><a href="global.html#getAuditEventType">getAuditEventType</a></li><li><a href="global.html#getClientIP">getClientIP</a></li><li><a href="global.html#getCorsConfig">getCorsConfig</a></li><li><a href="global.html#getErrorMessage">getErrorMessage</a></li><li><a href="global.html#getMetricsCollector">getMetricsCollector</a></li><li><a href="global.html#getMetricsEvents">getMetricsEvents</a></li><li><a href="global.html#getMetricsSummary">getMetricsSummary</a></li><li><a href="global.html#getMinutesBetween">getMinutesBetween</a></li><li><a href="global.html#getOrganizationSettings">getOrganizationSettings</a></li><li><a href="global.html#getPerformanceEvents">getPerformanceEvents</a></li><li><a href="global.html#getPerformanceStats">getPerformanceStats</a></li><li><a href="global.html#getQueryPerformanceEvents">getQueryPerformanceEvents</a></li><li><a href="global.html#getQueryPerformanceStats">getQueryPerformanceStats</a></li><li><a href="global.html#getSecurityConfig">getSecurityConfig</a></li><li><a href="global.html#getService">getService</a></li><li><a href="global.html#getServices">getServices</a></li><li><a href="global.html#getSlowQueriesSummary">getSlowQueriesSummary</a></li><li><a href="global.html#getWageBreakdown">getWageBreakdown</a></li><li><a href="global.html#handleApprovedRequest">handleApprovedRequest</a></li><li><a href="global.html#handleDatabaseError">handleDatabaseError</a></li><li><a href="global.html#hasSchedulingConflict">hasSchedulingConflict</a></li><li><a href="global.html#initializeServices">initializeServices</a></li><li><a href="global.html#knex">knex</a></li><li><a href="global.html#logError">logError</a></li><li><a href="global.html#logRequest">logRequest</a></li><li><a href="global.html#logSuspiciousActivity">logSuspiciousActivity</a></li><li><a href="global.html#logUnauthorizedCorsAttempt">logUnauthorizedCorsAttempt</a></li><li><a href="global.html#metricsEvents">metricsEvents</a></li><li><a href="global.html#notFoundHandler">notFoundHandler</a></li><li><a href="global.html#parseSize">parseSize</a></li><li><a href="global.html#parseSqlQuery">parseSqlQuery</a></li><li><a href="global.html#performanceEvents">performanceEvents</a></li><li><a href="global.html#performanceMonitor">performanceMonitor</a></li><li><a href="global.html#queryAuditLogs">queryAuditLogs</a></li><li><a href="global.html#queryCache">queryCache</a></li><li><a href="global.html#queryPerformanceEvents">queryPerformanceEvents</a></li><li><a href="global.html#queryValidationSchemas">queryValidationSchemas</a></li><li><a href="global.html#requestContextMiddleware">requestContextMiddleware</a></li><li><a href="global.html#requestContexts">requestContexts</a></li><li><a href="global.html#requestSizeLimit">requestSizeLimit</a></li><li><a href="global.html#resetAdvancedMetrics">resetAdvancedMetrics</a></li><li><a href="global.html#resetAllMetrics">resetAllMetrics</a></li><li><a href="global.html#resetPerformanceStats">resetPerformanceStats</a></li><li><a href="global.html#resetQueryPerformanceStats">resetQueryPerformanceStats</a></li><li><a href="global.html#sanitizeAll">sanitizeAll</a></li><li><a href="global.html#sanitizeBody">sanitizeBody</a></li><li><a href="global.html#sanitizeBodyForLogging">sanitizeBodyForLogging</a></li><li><a href="global.html#sanitizeError">sanitizeError</a></li><li><a href="global.html#sanitizeHeaders">sanitizeHeaders</a></li><li><a href="global.html#sanitizeInput">sanitizeInput</a></li><li><a href="global.html#sanitizeObject">sanitizeObject</a></li><li><a href="global.html#sanitizeParams">sanitizeParams</a></li><li><a href="global.html#sanitizeQuery">sanitizeQuery</a></li><li><a href="global.html#sanitizeString">sanitizeString</a></li><li><a href="global.html#securityConfig">securityConfig</a></li><li><a href="global.html#securityMonitoring">securityMonitoring</a></li><li><a href="global.html#sendAlertToWebhook">sendAlertToWebhook</a></li><li><a href="global.html#setupAlertHandlers">setupAlertHandlers</a></li><li><a href="global.html#setupGlobalErrorHandlers">setupGlobalErrorHandlers</a></li><li><a href="global.html#subtractMinutes">subtractMinutes</a></li><li><a href="global.html#testIntegrationConnection">testIntegrationConnection</a></li><li><a href="global.html#trackCacheOperation">trackCacheOperation</a></li><li><a href="global.html#trackDbQuery">trackDbQuery</a></li><li><a href="global.html#updateMetricsConfig">updateMetricsConfig</a></li><li><a href="global.html#validateAvailabilityWindow">validateAvailabilityWindow</a></li><li><a href="global.html#validateBody">validateBody</a></li><li><a href="global.html#validateContentType">validateContentType</a></li><li><a href="global.html#validateEnvironment">validateEnvironment</a></li><li><a href="global.html#validateFile">validateFile</a></li><li><a href="global.html#validateIdParam">validateIdParam</a></li><li><a href="global.html#validateParams">validateParams</a></li><li><a href="global.html#validateQuery">validateQuery</a></li><li><a href="global.html#validateRefereeQualifications">validateRefereeQualifications</a></li><li><a href="global.html#validateRequest">validateRequest</a></li><li><a href="global.html#validateUuidParam">validateUuidParam</a></li><li><a href="global.html#validationSummary">validationSummary</a></li><li><a href="global.html#withDatabaseError">withDatabaseError</a></li><li><a href="global.html#withErrorBoundary">withErrorBoundary</a></li><li><a href="global.html#withServiceTransaction">withServiceTransaction</a></li><li><a href="global.html#wrapDatabaseConnection">wrapDatabaseConnection</a></li><li><a href="global.html#wrapDatabaseQuery">wrapDatabaseQuery</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Aug 01 2025 16:15:52 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
